PUT _watcher/watch/vulnerability_report_watcher
{
  "trigger": { "schedule": { "interval": "5m" } },
  "input": {
    "chain": {
      "inputs": [
        {
          "open_reports": {
            "search": {
              "request": {
                "indices": ["pipeline-reports-*"],
                "rest_total_hits_as_int": true,
                "body": {
                  "size": 0,
                  "query": {
                    "bool": {
                      "filter": [
                        { "term": { "vulnerabilities.unified.status": "open" } },
                        { "term": { "doc_type": "vulnerability_report" } }
                      ]
                    }
                  },
                  "aggs": {
                    "total_open_documents": { "value_count": { "field": "_id" } },
                    "latest_documents": {
                      "top_hits": {
                        "size": 10,
                        "_source": ["vulnerabilities","service","tool","metadata"],
                        "sort":[{"@timestamp":{"order":"desc"}}]
                      }
                    }
                  }
                }
              }
            }
          }
        },
        {
          "resolved_report": {
            "search": {
              "request": {
                "indices": ["pipeline-reports-*"],
                "rest_total_hits_as_int": true,
                "body": {
                  "size": 1,
                  "query": {
                    "bool": {
                      "filter": [
                        { "term": { "doc_type": "resolved_report" } }
                      ]
                    }
                  },
                  "sort":[{"@timestamp":{"order":"desc"}}]
                }
              }
            }
          }
        }
      ]
    }
  },
  "condition": {
    "compare": { "ctx.payload.open_reports.aggregations.total_open_documents.value": { "gt": 0 } }
  },
  "transform": {
    "script": {
      "lang": "painless",
      "source": """
      def formatDate(String s){ if (s==null) return 'Unknown'; return s.length()>=10 ? s.substring(0,10) : s; }

def closed_vulns = [:];
if (ctx.payload.resolved_report.hits.hits.size()>0) {
def r = ctx.payload.resolved_report.hits.hits[0]._source;
if (r.resolved != null) {
for (def e : r.resolved) {
def id = e.unified?.vulnerability_id != null ? e.unified.vulnerability_id : e.vulnerability_id;
if (id != null) closed_vulns[id] = e.unified != null ? e.unified : e;
}
}
}

def hits = ctx.payload.open_reports.aggregations.latest_documents.hits.hits;
def processed = [:];
def msg_closed = '';
def msg_open = '';
int closed_count=0;
int open_count=0;

if (hits != null) {
for (def h : hits) {
def service = h._source.service?.name ?: (h._source.metadata?.service ?: 'Unknown');
def vulns = h._source.vulnerabilities;
if (vulns == null) continue;
for (def v : vulns) {
def uid = v.unified?.vulnerability_id;
if (uid==null) continue;
if (processed.containsKey(uid)) continue;
processed[uid]=true;
if (closed_vulns.containsKey(uid)) {
closed_count++;
def c = closed_vulns[uid];
msg_closed += ':white_check_mark: ['+uid+'] service:'+service+' corrected (first_seen:'+formatDate(c.first_seen)+', resolved:'+formatDate(c.resolution_date)+')\\n';
} else {
open_count++;
def sev = v.unified?.severity ?: 'INFO';
def assignee = v.unified?.assignee ?: 'Non Assigné';
msg_open += ':warning: ['+sev+'] '+uid+' ('+service+') assigné à '+assignee+'\\n';
}
}
}
}

def final_msg = '';
if (closed_count>0) {
final_msg += '*VULNÉRABILITÉS RÉSOLUES ('+closed_count+')*\\n'+msg_closed+'\\n------------------------------------------------\\n';
}
if (open_count>0) {
final_msg += '*VULNÉRABILITÉS OUVERTES ('+open_count+')*\\n'+msg_open;
}
if (final_msg.length()==0) final_msg=':rocket: Pas de vulnérabilités ouvertes.';

return ['message_to_slack': final_msg, 'local_message': final_msg];
"""
}
},
"actions": {
"notify_slack": {
"webhook": {
"scheme": "https",
"host": "hooks.slack.com",
"port": 443,
"method": "post",
"path": "/services/T09PWFSJWCW/B09QBL7BAAV/fKELOWe8birV7V7u5z7di5pS",
"headers": { "Content-Type": "application/json" },
"body": "{\"text\":\"{{ctx.payload.message_to_slack}}\"}"
}
},
"notify_local": {
"logging": {
"level": "info",
"text": "{{ctx.payload.local_message}}"
}
}
}
}
